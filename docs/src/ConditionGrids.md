
### ConditionGrids

The `ConditionGrid` type offers a way to link a vector of `DataModel`s, which in turn each contain a dataset and corresponding model to describe said data.
Overall, the `ConditionGrid` takes a `Vector` of "outer parameters", i.e. a vector of parameters which are visible to the outside, and generates from these shared outer parameters new individual parameter vectors for each of the individual "conditions", i.e. `DataModel`s.
This terminology is inspired by the [**dMod**](https://github.com/dkaschek/dMod) package for dynamic modelling and parameter estimation in R.

In summary, a `ConditionGrid` requires at least the specification of a `Vector` of `DataModel`s and a `Vector` of Functions, which perform the parameter transformations.
For instance, for two datasets with different offset, they can be described by a shared slope parameter via:
```@example Conditions
using InformationGeometry
DM1 = DataModel(DataSet(1:3,      [4,5,6.5], [0.5,0.45,0.6]), (x,p)->p[1].*x .+ p[2]; name="Condition 1")
DM2 = DataModel(DataSet(1:3, 5 .+ [4,5,6.5], [0.5,0.45,0.6]), (x,p)->p[1].*x .+ p[2]; name="Condition 2")
ParameterTrafo = [ViewElements([1,2]), ViewElements([1,3])]
CG = ConditionGrid([DM1, DM2], ParameterTrafo, rand(3); pnames=["Slope", "Offset_1", "Offset_2"])
```
!!! note
    The individual `DataModel`s passed to `ConditionGrid` must have unique names.
    The name of a `DataModel` can be set by passing a `String` or `Symbol` via the keyword `name` to the constructor, or alternatively via `remake(DM; name="CreativeConditionName")` given a `DataModel` object `DM`.

Optionally, it is possible to specify an additional prior for the outer parameters (in addition to the possible individual priors of the contained `DataModel`s), a parameter domain for the outer parameters and custom parameter names via keyword arguments to the `ConditionGrid` constructor.
To the outside, the `ConditionGrid` behaves like a single `DataModel` in terms of plotting, evaluating functions like the likelihood, optimization and computation of parameter profiles. The individual conditions can be accessed via `Conditions(CG)`.

!!! note
    If optimization is performed on a `ConditionGrid`, the resulting MLE is not propagated to the individual conditions.
    Therefore `MLE(Conditions(CG)[i])` will return the original MLEs of the individual `DataModel`s.
    The individual MLEs based on the current vector of outer parameters can be computed via `CG.Trafos[i](MLE(CG))`.

If no vector of parameter transformations is specified, the default vector of parameter transformations will keep the individual model parameters separate such that the outer parameters are given by the vertical concatenation of the parameter configurations of the individual conditions. 

Predictions for individual conditions at ``x``-values `xran` can be generated by passing the condition name as a `Symbol` as the last positional argument to `EmbeddingMap` or `EmbeddingMatrix`:
```@example Conditions
xran = range(0, 4; length=151)
Y = EmbeddingMap(CG, MLE(CG), xran, Symbol("Condition 1"))
```


```@docs
ConditionGrid
```